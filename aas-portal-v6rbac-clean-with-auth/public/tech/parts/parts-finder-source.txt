<!-- 
  AAS Parts Finder v2.2 â€” Layout-Stable Dark Glass Edition
  FIXES: Search bar layout jump, recent searches collapse, grid reflow
  
  Changes from v2.1:
  1. Removed scrollIntoView() that caused page jump on every search
  2. Added min-height to recent searches wrapper to prevent collapse
  3. Added min-height preservation to grid during rerender
  4. Made scroll-to-top optional and user-triggered only
-->

<div id="aasPartsFinder" class="pf-wrap">
  
  <!-- Screen reader announcements -->
  <div id="pfAnnounce" class="sr-only" aria-live="polite" aria-atomic="true"></div>
  
  <div class="pf-head">
    <div>
      <div class="pf-title">Parts Finder</div>
      <div class="pf-sub">Search by part number, manufacturer, or description.</div>
    </div>

    <div class="pf-actions">
      <div class="pf-search-wrap">
        <input id="pfSearch" class="pf-search" type="search" placeholder="Search partsâ€¦" autocomplete="off" spellcheck="false" />
        <kbd class="pf-kbd">âŒ˜K</kbd>
      </div>
      <select id="pfMfr" class="pf-select" aria-label="Manufacturer filter"></select>
    </div>
  </div>

  <!-- Recent Searches - NOW WITH STABLE HEIGHT -->
  <div id="pfRecentSearches" class="pf-recent-wrap"></div>

  <!-- Stats + Connection Status -->
  <div class="pf-stats-row">
    <div id="pfStats" class="pf-stats">Loadingâ€¦</div>
    <div id="pfStatus" class="pf-status"></div>
  </div>
  
  <div id="pfGrid" class="pf-grid" role="list" aria-label="Parts list"></div>

  <div class="pf-footer">
    <button id="pfLoadMore" class="pf-btn pf-btn--wide pf-btn--glass" type="button" style="display:none;">
      <span class="pf-btn__text">Load more</span>
      <span class="pf-btn__icon">â†“</span>
    </button>
  </div>
  
  <!-- Infinite scroll sentinel -->
  <div id="pfSentinel" class="pf-sentinel" aria-hidden="true"></div>

  <!-- QR Modal -->
  <div id="pfModal" class="pf-modal" aria-hidden="true">
    <div class="pf-modal__backdrop"></div>
    <div class="pf-modal__card" role="dialog" aria-modal="true">
      <div class="pf-modal__top">
        <div>
          <div id="pfModalTitle" class="pf-modal__title">QR Code</div>
          <div id="pfModalSub" class="pf-modal__sub"></div>
        </div>
        <button id="pfModalClose" class="pf-btn" type="button">
          <span>Close</span>
          <span class="pf-modal__esc">esc</span>
        </button>
      </div>
      <div class="pf-modal__body">
        <img id="pfModalQR" class="pf-modal__qr" alt="QR code" />
        <div id="pfModalPayload" class="pf-modal__payload"></div>
      </div>
    </div>
  </div>
</div>

<style>
/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   AAS PARTS FINDER v2.2 â€” Layout-Stable Dark Glass Edition
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

/* Base */
#aasPartsFinder {
  --pf-bg: rgba(11,18,32,.55);
  --pf-bg-solid: rgba(11,18,32,.92);
  --pf-bg-card: rgba(11,18,32,.50);
  --pf-border: rgba(255,255,255,.14);
  --pf-border-hover: rgba(255,255,255,.22);
  --pf-text: #e6edf3;
  --pf-text-muted: rgba(230,237,243,.75);
  --pf-text-dim: rgba(230,237,243,.55);
  --pf-accent: rgba(31,111,235,1);
  --pf-accent-glow: rgba(31,111,235,.40);
  --pf-accent-soft: rgba(120,190,255,.9);
  --pf-highlight: rgba(120,190,255,.25);
  --pf-highlight-text: #7dd3fc;
  --pf-success: rgba(34,197,94,.9);
  --pf-radius: 14px;
  --pf-radius-lg: 18px;
  --pf-blur: blur(12px);
  
  max-width: 1200px;
  margin: 0 auto;
  padding: 18px 16px 40px;
  color: var(--pf-text);
}

#aasPartsFinder * {
  box-sizing: border-box;
  font-family: system-ui, -apple-system, "Segoe UI", Roboto, Arial, sans-serif;
}

/* Header */
#aasPartsFinder .pf-head {
  display: flex;
  justify-content: space-between;
  gap: 14px;
  flex-wrap: wrap;
  align-items: flex-end;
  margin-bottom: 12px;
}

#aasPartsFinder .pf-title {
  font-size: 24px;
  font-weight: 950;
  letter-spacing: -.02em;
  background: linear-gradient(135deg, var(--pf-text) 0%, var(--pf-text-muted) 100%);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
}

#aasPartsFinder .pf-sub {
  color: var(--pf-text-muted);
  margin-top: 4px;
}

/* Actions row */
#aasPartsFinder .pf-actions {
  display: flex;
  gap: 10px;
  flex-wrap: wrap;
  align-items: center;
}

/* Search wrapper with kbd hint */
#aasPartsFinder .pf-search-wrap {
  position: relative;
  display: flex;
  align-items: center;
}

#aasPartsFinder .pf-search,
#aasPartsFinder .pf-select {
  border-radius: var(--pf-radius);
  border: 1px solid var(--pf-border);
  background: var(--pf-bg);
  color: var(--pf-text);
  padding: 10px 12px;
  outline: none;
  backdrop-filter: var(--pf-blur);
  -webkit-backdrop-filter: var(--pf-blur);
  transition: border-color .15s ease, box-shadow .15s ease;
}

#aasPartsFinder .pf-search {
  min-width: 260px;
  padding-right: 52px;
}

#aasPartsFinder .pf-search:focus {
  border-color: var(--pf-accent-glow);
  box-shadow: 0 0 0 3px rgba(31,111,235,.15), 0 0 20px rgba(31,111,235,.1);
}

#aasPartsFinder .pf-search::placeholder {
  color: var(--pf-text-dim);
}

#aasPartsFinder .pf-select {
  min-width: 220px;
  cursor: pointer;
}

#aasPartsFinder .pf-select:focus {
  border-color: var(--pf-accent-glow);
}

/* Keyboard shortcut badge */
#aasPartsFinder .pf-kbd {
  position: absolute;
  right: 10px;
  top: 50%;
  transform: translateY(-50%);
  font-size: 11px;
  font-weight: 600;
  color: var(--pf-text-dim);
  background: rgba(255,255,255,.08);
  border: 1px solid rgba(255,255,255,.10);
  border-radius: 6px;
  padding: 3px 7px;
  pointer-events: none;
  font-family: system-ui, sans-serif;
  transition: opacity .15s ease;
}

#aasPartsFinder .pf-search:focus + .pf-kbd {
  opacity: 0;
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   FIX #1: Recent searches - STABLE HEIGHT to prevent layout shift
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
#aasPartsFinder .pf-recent-wrap {
  margin-bottom: 12px;
  min-height: 36px;  /* FIXED: Reserve space even when empty */
  display: flex;
  align-items: center;
  /* Removed: transition that caused visual instability */
}

/* When empty, still takes up space but is invisible */
#aasPartsFinder .pf-recent-wrap:empty {
  /* REMOVED: display: none - this was causing the jump */
  visibility: hidden;  /* Takes space but invisible */
}

#aasPartsFinder .pf-recent {
  display: flex;
  align-items: center;
  gap: 8px;
  flex-wrap: wrap;
}

#aasPartsFinder .pf-recent__label {
  font-size: 12px;
  font-weight: 700;
  color: var(--pf-text-dim);
  text-transform: uppercase;
  letter-spacing: .05em;
}

#aasPartsFinder .pf-recent__tags {
  display: flex;
  gap: 6px;
  flex-wrap: wrap;
  align-items: center;
}

#aasPartsFinder .pf-recent__tag {
  background: rgba(255,255,255,.06);
  border: 1px solid var(--pf-border);
  border-radius: 999px;
  padding: 5px 12px;
  font-size: 12px;
  font-weight: 600;
  color: var(--pf-text-muted);
  cursor: pointer;
  transition: all .15s ease;
  backdrop-filter: var(--pf-blur);
  -webkit-backdrop-filter: var(--pf-blur);
}

#aasPartsFinder .pf-recent__tag:hover {
  background: rgba(255,255,255,.10);
  border-color: var(--pf-border-hover);
  color: var(--pf-text);
}

#aasPartsFinder .pf-recent__clear {
  background: transparent;
  border: none;
  color: var(--pf-text-dim);
  font-size: 16px;
  cursor: pointer;
  padding: 4px 6px;
  line-height: 1;
  opacity: .6;
  transition: opacity .15s ease, color .15s ease;
}

#aasPartsFinder .pf-recent__clear:hover {
  opacity: 1;
  color: #f87171;
}

/* Stats row */
#aasPartsFinder .pf-stats-row {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin: 10px 0 14px;
  gap: 12px;
}

#aasPartsFinder .pf-stats {
  color: var(--pf-text-muted);
  font-size: 14px;
}

#aasPartsFinder .pf-status {
  display: flex;
  align-items: center;
  gap: 6px;
  font-size: 12px;
  font-weight: 600;
  color: var(--pf-text-dim);
}

#aasPartsFinder .pf-status:empty {
  display: none;
}

#aasPartsFinder .pf-status__dot {
  width: 6px;
  height: 6px;
  border-radius: 50%;
  background: var(--pf-success);
  box-shadow: 0 0 8px var(--pf-success);
  animation: pf-pulse 2s ease-in-out infinite;
}

#aasPartsFinder .pf-status--offline .pf-status__dot {
  background: #f59e0b;
  box-shadow: 0 0 8px #f59e0b;
  animation: none;
}

@keyframes pf-pulse {
  0%, 100% { opacity: 1; }
  50% { opacity: .5; }
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   FIX #2: Grid - STABLE HEIGHT during rerender
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
#aasPartsFinder .pf-grid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(220px, 1fr));
  gap: 12px;
  min-height: 200px;  /* FIXED: Prevent collapse during rerender */
  transition: opacity .15s ease;  /* Faster transition */
}

#aasPartsFinder .pf-grid.is-loading {
  opacity: .6;  /* Less dramatic opacity change */
  pointer-events: none;
}

/* Glass cards */
#aasPartsFinder .pf-card {
  border-radius: var(--pf-radius-lg);
  border: 1px solid rgba(255,255,255,.10);
  background: var(--pf-bg-card);
  overflow: hidden;
  box-shadow: 0 14px 40px rgba(0,0,0,.35);
  backdrop-filter: var(--pf-blur);
  -webkit-backdrop-filter: var(--pf-blur);
  transition: transform .14s ease, border-color .14s ease, box-shadow .14s ease;
}

#aasPartsFinder .pf-card:hover {
  transform: translateY(-2px);
  border-color: rgba(31,111,235,.22);
  box-shadow: 0 22px 60px rgba(0,0,0,.45);
}

#aasPartsFinder .pf-card:focus {
  outline: none;
  border-color: var(--pf-accent-glow);
  box-shadow: 0 0 0 2px rgba(31,111,235,.3), 0 22px 60px rgba(0,0,0,.45);
}

#aasPartsFinder .pf-imgWrap {
  height: 168px;
  background: rgba(255,255,255,.04);
  display: flex;
  align-items: center;
  justify-content: center;
  position: relative;
  overflow: hidden;
}

#aasPartsFinder img.pf-img {
  width: 100%;
  height: 168px;
  object-fit: contain;
  display: block;
  transition: transform .3s ease;
}

#aasPartsFinder .pf-card:hover img.pf-img {
  transform: scale(1.02);
}

#aasPartsFinder .pf-noimg {
  color: var(--pf-text-dim);
  font-size: 12px;
  padding: 10px;
  text-align: center;
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 6px;
}

#aasPartsFinder .pf-noimg__icon {
  font-size: 24px;
  opacity: .4;
}

#aasPartsFinder .pf-body {
  padding: 10px 10px 12px;
}

#aasPartsFinder .pf-part {
  font-weight: 950;
  font-size: 16px;
  line-height: 1.2;
}

#aasPartsFinder .pf-mfr {
  margin-top: 2px;
  color: rgba(230,237,243,.70);
  font-size: 13px;
}

/* MFG Part Number */
#aasPartsFinder .pf-mfg {
  margin-top: 4px;
  color: var(--pf-accent-soft);
  font-size: 12px;
  font-weight: 600;
  font-family: "SF Mono", Monaco, Consolas, monospace;
  opacity: 0.85;
}

#aasPartsFinder .pf-mfg::before {
  content: "MFG# ";
  color: var(--pf-text-dim);
  font-weight: 700;
  font-family: system-ui, sans-serif;
}

#aasPartsFinder .pf-desc {
  margin-top: 8px;
  color: rgba(230,237,243,.78);
  font-size: 13px;
  line-height: 1.35;
  min-height: 34px;
  display: -webkit-box;
  -webkit-line-clamp: 2;
  -webkit-box-orient: vertical;
  overflow: hidden;
}

/* Search highlighting (dark theme friendly) */
#aasPartsFinder .pf-hl {
  color: var(--pf-highlight-text);
  background: var(--pf-highlight);
  padding: 1px 4px;
  margin: -1px -2px;
  border-radius: 4px;
  font-weight: inherit;
}

#aasPartsFinder .pf-row {
  display: flex;
  gap: 8px;
  flex-wrap: wrap;
  margin-top: 12px;
}

/* Buttons */
#aasPartsFinder .pf-btn {
  padding: 9px 12px;
  border-radius: 12px;
  border: 1px solid var(--pf-border);
  background: rgba(255,255,255,.06);
  color: var(--pf-text);
  cursor: pointer;
  font-weight: 800;
  font-size: 13px;
  text-decoration: none;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  gap: 6px;
  user-select: none;
  -webkit-tap-highlight-color: transparent;
  transition: all .12s ease;
}

#aasPartsFinder .pf-btn:hover {
  filter: brightness(1.10);
  border-color: var(--pf-border-hover);
}

#aasPartsFinder .pf-btn:active {
  transform: translateY(1px);
}

#aasPartsFinder .pf-btn--wide {
  width: min(420px, 100%);
}

#aasPartsFinder .pf-btn--glass {
  background: linear-gradient(180deg, rgba(255,255,255,.08), rgba(255,255,255,.04));
  backdrop-filter: var(--pf-blur);
  -webkit-backdrop-filter: var(--pf-blur);
}

#aasPartsFinder .pf-btn__icon {
  font-size: 14px;
  opacity: .7;
}

/* Limble button (primary glass) */
#aasPartsFinder .pf-btn--limble {
  border-color: var(--pf-accent-glow);
  background: linear-gradient(180deg, rgba(31,111,235,.22), rgba(31,111,235,.10));
  box-shadow: 0 12px 28px rgba(0,0,0,.28);
}

#aasPartsFinder .pf-btn--limble:hover {
  border-color: rgba(31,111,235,.55);
  filter: brightness(1.14);
}

#aasPartsFinder .pf-btn--limble::before {
  content: "";
  width: 8px;
  height: 8px;
  border-radius: 999px;
  background: var(--pf-accent-soft);
  box-shadow: 0 0 0 3px rgba(120,190,255,.15);
}

/* Share button */
#aasPartsFinder .pf-btn--share {
  border-color: rgba(120,190,255,.28);
  background: linear-gradient(180deg, rgba(120,190,255,.10), rgba(255,255,255,.05));
}

#aasPartsFinder .pf-btn--share:hover {
  border-color: rgba(120,190,255,.40);
  filter: brightness(1.12);
}

/* Copy success state */
#aasPartsFinder .pf-btn--success {
  border-color: rgba(34,197,94,.5) !important;
  background: linear-gradient(180deg, rgba(34,197,94,.20), rgba(34,197,94,.08)) !important;
}

/* Mini buttons (popover) */
#aasPartsFinder .pf-btn--mini {
  padding: 8px 10px;
  border-radius: 10px;
  font-weight: 900;
  font-size: 12px;
}

/* Share popover */
#aasPartsFinder .pf-pop {
  position: fixed;
  z-index: 10001;
  display: flex;
  gap: 8px;
  align-items: center;
  padding: 10px 12px;
  border-radius: var(--pf-radius);
  border: 1px solid rgba(255,255,255,.16);
  background: var(--pf-bg-solid);
  box-shadow: 0 22px 70px rgba(0,0,0,.60);
  backdrop-filter: var(--pf-blur);
  -webkit-backdrop-filter: var(--pf-blur);
}

#aasPartsFinder .pf-pop__label {
  font-size: 12px;
  font-weight: 900;
  color: var(--pf-text-muted);
  padding-right: 2px;
  white-space: nowrap;
}

/* Loading skeletons */
#aasPartsFinder .pf-skel {
  border-radius: var(--pf-radius-lg);
  border: 1px solid rgba(255,255,255,.08);
  background: rgba(11,18,32,.40);
  overflow: hidden;
  box-shadow: 0 10px 28px rgba(0,0,0,.25);
}

#aasPartsFinder .pf-skel__top {
  height: 168px;
  background: linear-gradient(90deg, rgba(255,255,255,.03), rgba(255,255,255,.08), rgba(255,255,255,.03));
  background-size: 200% 100%;
  animation: pfshine 1.1s linear infinite;
}

#aasPartsFinder .pf-skel__body {
  padding: 10px;
}

#aasPartsFinder .pf-skel__line {
  height: 10px;
  border-radius: 999px;
  background: rgba(255,255,255,.08);
  margin: 10px 0;
}

#aasPartsFinder .pf-skel__line.short { width: 55%; }
#aasPartsFinder .pf-skel__line.med { width: 75%; }
#aasPartsFinder .pf-skel__line.long { width: 92%; }

@keyframes pfshine {
  0% { background-position: 200% 0; }
  100% { background-position: -200% 0; }
}

/* Error / Empty states */
#aasPartsFinder .pf-card--error,
#aasPartsFinder .pf-card--empty {
  grid-column: 1 / -1;
  max-width: 400px;
  margin: 2rem auto;
}

#aasPartsFinder .pf-card--error .pf-body,
#aasPartsFinder .pf-card--empty .pf-body {
  text-align: center;
  padding: 2.5rem 1.5rem;
}

#aasPartsFinder .pf-state-icon {
  font-size: 48px;
  margin-bottom: 1rem;
  opacity: .6;
}

#aasPartsFinder .pf-card--error .pf-part,
#aasPartsFinder .pf-card--empty .pf-part {
  font-size: 18px;
  margin-bottom: 8px;
}

#aasPartsFinder .pf-card--error .pf-desc,
#aasPartsFinder .pf-card--empty .pf-desc {
  min-height: auto;
  margin-bottom: 1.5rem;
}

#aasPartsFinder .pf-btn--retry {
  border-color: rgba(251,146,60,.4);
  background: linear-gradient(180deg, rgba(251,146,60,.18), rgba(251,146,60,.08));
}

#aasPartsFinder .pf-btn--retry:hover {
  border-color: rgba(251,146,60,.6);
}

/* Modal */
#aasPartsFinder .pf-modal {
  position: fixed;
  inset: 0;
  display: none;
  place-items: center;
  z-index: 9999;
}

#aasPartsFinder .pf-modal.is-open {
  display: grid;
}

#aasPartsFinder .pf-modal__backdrop {
  position: absolute;
  inset: 0;
  background: rgba(0,0,0,.65);
  backdrop-filter: blur(4px);
  -webkit-backdrop-filter: blur(4px);
}

#aasPartsFinder .pf-modal__card {
  position: relative;
  z-index: 1;
  width: min(440px, 92vw);
  border-radius: var(--pf-radius-lg);
  border: 1px solid rgba(255,255,255,.16);
  background: var(--pf-bg-solid);
  box-shadow: 0 22px 70px rgba(0,0,0,.60);
  padding: 14px;
  transform: scale(.95);
  opacity: 0;
  animation: pf-modal-in .2s ease forwards;
}

@keyframes pf-modal-in {
  to { transform: scale(1); opacity: 1; }
}

#aasPartsFinder .pf-modal__top {
  display: flex;
  justify-content: space-between;
  gap: 12px;
  align-items: flex-start;
}

#aasPartsFinder .pf-modal__title {
  font-weight: 950;
  font-size: 16px;
}

#aasPartsFinder .pf-modal__sub {
  color: var(--pf-text-muted);
  font-size: 13px;
  margin-top: 2px;
}

#aasPartsFinder .pf-modal__esc {
  font-size: 10px;
  font-weight: 600;
  color: var(--pf-text-dim);
  background: rgba(255,255,255,.08);
  padding: 2px 6px;
  border-radius: 4px;
  margin-left: 6px;
}

#aasPartsFinder .pf-modal__body {
  margin-top: 12px;
}

#aasPartsFinder .pf-modal__qr {
  width: 100%;
  height: auto;
  border-radius: var(--pf-radius);
  background: #fff;
}

#aasPartsFinder .pf-modal__payload {
  margin-top: 10px;
  color: var(--pf-text-muted);
  font-size: 13px;
  word-break: break-word;
  font-family: "SF Mono", Monaco, monospace;
}

/* Footer */
#aasPartsFinder .pf-footer {
  margin-top: 1.5rem;
  display: flex;
  justify-content: center;
}

/* Sentinel */
#aasPartsFinder .pf-sentinel {
  height: 1px;
  width: 100%;
}

/* Screen reader only */
#aasPartsFinder .sr-only {
  position: absolute;
  width: 1px;
  height: 1px;
  padding: 0;
  margin: -1px;
  overflow: hidden;
  clip: rect(0, 0, 0, 0);
  white-space: nowrap;
  border: 0;
}

/* Responsive */
@media (max-width: 520px) {
  #aasPartsFinder .pf-search {
    min-width: 100%;
  }
  
  #aasPartsFinder .pf-select {
    min-width: 100%;
  }
  
  #aasPartsFinder .pf-grid {
    grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
  }
  
  #aasPartsFinder .pf-kbd {
    display: none;
  }
  
  #aasPartsFinder .pf-row {
    flex-direction: column;
  }
  
  #aasPartsFinder .pf-btn {
    width: 100%;
  }
  
  /* Reduce reserved space on mobile */
  #aasPartsFinder .pf-recent-wrap {
    min-height: 32px;
  }
}

/* Dark mode scrollbar (optional enhancement) */
#aasPartsFinder ::-webkit-scrollbar {
  width: 8px;
  height: 8px;
}

#aasPartsFinder ::-webkit-scrollbar-track {
  background: transparent;
}

#aasPartsFinder ::-webkit-scrollbar-thumb {
  background: rgba(255,255,255,.15);
  border-radius: 4px;
}

#aasPartsFinder ::-webkit-scrollbar-thumb:hover {
  background: rgba(255,255,255,.25);
}
</style>

<script>
/**
 * AAS Parts Finder v2.2 â€” Layout-Stable Dark Glass Edition
 * 
 * FIXES FROM v2.1:
 * 1. Removed scrollIntoView() that caused page jump on search
 * 2. Added min-height to recent searches wrapper
 * 3. Preserve grid height during rerender to prevent collapse
 * 4. Smoother transitions during filter changes
 */
(() => {
  "use strict";

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // CONFIGURATION
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  const CONFIG = {
    CSV_URL: "https://docs.google.com/spreadsheets/d/e/2PACX-1vQLWrgcUPv3oD7tIiKCQnDYEnGvlwZ5rYiN-4BhOdZsEV52XvI6NCy7wSqmCgrN02pdKKfSc9w6Fwx7/pub?gid=0&single=true&output=csv",
    LIMBLE_URL: "https://auth.limblecmms.com/",
    
    INITIAL_RENDER: 24,
    PAGE_SIZE: 36,
    SKELETON_COUNT: 12,
    
    CACHE_KEY: "aas_parts_v2",
    CACHE_TTL: 1000 * 60 * 60, // 1 hour
    RECENT_KEY: "aas_recent",
    MAX_RECENT: 5,
    
    DEBOUNCE_MS: 150,  // Slightly increased for smoother typing
    POPOVER_MS: 5200,
    FEEDBACK_MS: 900,
    
    QR_SIZE: 420,
    QR_MARGIN: 6,
    LIMBLE_MAX: 360,
    
    DEFAULT_MFR: "",
    PINNED_MFR: "BEA",
    HIDE_MFR: new Set(["ADC CONTROLS", "AMR", "AMR CONTROLS"]),
    ERRORS: new Set(["#N/A","#REF!","#VALUE!","#DIV/0!","#NUM!","#NAME?","#ERROR!","#NULL!"]),
  };

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // STATE
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  let all = [], filtered = [], q = "", mfr = CONFIG.DEFAULT_MFR;
  let visible = 0, loading = false;
  let activePop = null, popTimer = null, observer = null, prevFocus = null;
  let lastGridHeight = 0;  // NEW: Track grid height to prevent collapse

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // UTILITIES
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  const el = id => document.getElementById(id);
  const norm = s => (s ?? "").toString().trim();
  const lower = s => norm(s).toLowerCase();
  
  function debounce(fn, ms = CONFIG.DEBOUNCE_MS) {
    let t;
    return (...a) => { clearTimeout(t); t = setTimeout(() => fn(...a), ms); };
  }

  function escapeHtml(s) {
    const d = document.createElement("div");
    d.textContent = s;
    return d.innerHTML;
  }

  function escapeRx(s) {
    return s.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // URL STATE
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  function syncURL() {
    const p = new URLSearchParams();
    if (q) p.set("q", q);
    if (mfr) p.set("mfr", mfr);
    const url = p.toString() ? `${location.pathname}?${p}` : location.pathname;
    history.replaceState(null, "", url);
  }

  function loadURL() {
    const p = new URLSearchParams(location.search);
    q = p.get("q") || "";
    mfr = p.get("mfr") || CONFIG.DEFAULT_MFR;
    const sEl = el("pfSearch"), mEl = el("pfMfr");
    if (sEl) sEl.value = q;
    if (mEl) mEl.value = mfr;
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // CACHING
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  function getCache() {
    try {
      const c = localStorage.getItem(CONFIG.CACHE_KEY);
      if (!c) return null;
      const { data, ts } = JSON.parse(c);
      return { data, stale: Date.now() - ts > CONFIG.CACHE_TTL };
    } catch { return null; }
  }

  function setCache(data) {
    try {
      localStorage.setItem(CONFIG.CACHE_KEY, JSON.stringify({ data, ts: Date.now() }));
    } catch {}
  }

  async function fetchData(useCache = true) {
    const c = useCache ? getCache() : null;
    if (c && !c.stale) return { text: c.data, cached: true };
    
    try {
      const r = await fetch(`${CONFIG.CSV_URL}&t=${Date.now()}`, { cache: "no-store" });
      if (!r.ok) throw new Error(`HTTP ${r.status}`);
      const text = await r.text();
      setCache(text);
      return { text, cached: false };
    } catch (e) {
      if (c) return { text: c.data, cached: true, stale: true };
      throw e;
    }
  }

  function showStatus(offline = false) {
    const s = el("pfStatus");
    if (!s) return;
    if (offline) {
      s.className = "pf-status pf-status--offline";
      s.innerHTML = `<span class="pf-status__dot"></span><span>Cached data</span>`;
    } else {
      s.innerHTML = `<span class="pf-status__dot"></span><span>Live</span>`;
    }
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // RECENT SEARCHES
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  function getRecent() {
    try { return JSON.parse(localStorage.getItem(CONFIG.RECENT_KEY) || "[]"); }
    catch { return []; }
  }

  function saveRecent(query) {
    const x = norm(query);
    if (!x || x.length < 2) return;
    try {
      let r = getRecent().filter(s => s.toLowerCase() !== x.toLowerCase());
      r = [x, ...r].slice(0, CONFIG.MAX_RECENT);
      localStorage.setItem(CONFIG.RECENT_KEY, JSON.stringify(r));
      renderRecent();
    } catch {}
  }

  function clearRecent() {
    localStorage.removeItem(CONFIG.RECENT_KEY);
    renderRecent();
  }

  function renderRecent() {
    const wrap = el("pfRecentSearches");
    if (!wrap) return;
    const r = getRecent();
    
    // FIX: Don't clear innerHTML, update content while preserving layout space
    if (!r.length) { 
      wrap.innerHTML = ""; 
      return; 
    }
    
    wrap.innerHTML = `
      <div class="pf-recent">
        <span class="pf-recent__label">Recent</span>
        <div class="pf-recent__tags">
          ${r.map(s => `<button type="button" class="pf-recent__tag" data-q="${escapeHtml(s)}">${escapeHtml(s)}</button>`).join("")}
          <button type="button" class="pf-recent__clear" title="Clear">Ã—</button>
        </div>
      </div>`;
    
    wrap.querySelectorAll(".pf-recent__tag").forEach(btn => {
      btn.onclick = () => {
        const sEl = el("pfSearch");
        if (sEl) { sEl.value = btn.dataset.q; q = btn.dataset.q; recompute(); }
      };
    });
    wrap.querySelector(".pf-recent__clear")?.addEventListener("click", clearRecent);
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // DATA PARSING
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  function clean(raw) {
    const s = norm(raw);
    if (!s) return "";
    const u = s.toUpperCase();
    if (CONFIG.ERRORS.has(u)) return "";
    if (["OBSTRUCTION","LOCK","LOCKED"].includes(u)) return "";
    return s;
  }

  function okStatus(s) {
    const c = clean(s);
    if (!c) return true;
    if (/^matched$/i.test(c)) return true;
    if (/(obstruction|lock|blocked|error)/i.test(c)) return false;
    return false;
  }

  function parseCSV(text) {
    const rows = [];
    let cur = "", inQ = false;
    const out = [];
    const pushCell = () => { out.push(cur); cur = ""; };
    const pushRow = () => { rows.push([...out]); out.length = 0; };

    for (let i = 0; i < text.length; i++) {
      const ch = text[i];
      if (ch === '"') {
        if (inQ && text[i+1] === '"') { cur += '"'; i++; }
        else inQ = !inQ;
      } else if (ch === "," && !inQ) pushCell();
      else if (ch === "\n" && !inQ) { pushCell(); pushRow(); }
      else if (ch !== "\r") cur += ch;
    }
    if (cur.length || out.length) { pushCell(); pushRow(); }
    if (!rows.length) return [];

    const hdr = rows[0].map(h => norm(h).replace(/^\uFEFF/, "").toLowerCase());
    const idx = n => hdr.indexOf(n.toLowerCase());
    const [iK,iM,iD,iP,iI,iQ,iS] = ["key","manufacturer","description","mfg_part","image_id","qr_payload","match_status"].map(idx);

    return rows.slice(1).map(r => ({
      key: clean(r[iK] ?? ""),
      manufacturer: clean(r[iM] ?? ""),
      description: clean(r[iD] ?? ""),
      mfg_part: clean(r[iP] ?? ""),
      image_id: clean(r[iI] ?? ""),
      qr_payload: clean(r[iQ] ?? ""),
      match_status: clean(r[iS] ?? ""),
    })).filter(x => x.key && okStatus(x.match_status) && !CONFIG.HIDE_MFR.has(x.manufacturer));
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // SEARCH
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  function normalize(s) { return lower(s).replace(/[^a-z0-9]+/g, " ").trim(); }
  function buildBlob(p) { return normalize(`${p.key} ${p.mfg_part} ${p.manufacturer} ${p.description}`); }
  function getTerms() { return normalize(q).split(" ").filter(Boolean); }

  function matches(item) {
    if (mfr && item.manufacturer !== mfr) return false;
    if (!q) return true;
    const terms = getTerms();
    if (!terms.length) return true;
    const hay = item._blob || buildBlob(item);
    return terms.every(t => hay.includes(t));
  }

  function highlight(text, terms) {
    if (!terms.length || !text) return escapeHtml(text || "â€”");
    const esc = escapeHtml(text);
    const rx = new RegExp(`(${terms.map(escapeRx).join("|")})`, "gi");
    return esc.replace(rx, '<span class="pf-hl">$1</span>');
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // IMAGE & TEXT HELPERS
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  const driveImg = id => id ? `https://lh3.googleusercontent.com/d/${encodeURIComponent(id)}` : "";
  const qrImg = p => p ? `https://api.qrserver.com/v1/create-qr-code/?size=${CONFIG.QR_SIZE}x${CONFIG.QR_SIZE}&margin=${CONFIG.QR_MARGIN}&data=${encodeURIComponent(p)}` : "";

  function shareText(p) {
    return [`Part: ${p.key}`, p.mfg_part ? `MFG#: ${p.mfg_part}` : "", p.description ? `Desc: ${p.description}` : "", p.manufacturer ? `Mfr: ${p.manufacturer}` : ""].filter(Boolean).join("\n");
  }

  function limbleText(p) {
    let out = [p.key, p.mfg_part ? `MFG: ${p.mfg_part}` : "", p.manufacturer ? `Mfr: ${p.manufacturer}` : "", p.description ? `Desc: ${p.description}` : ""].filter(Boolean).join(" | ").replace(/\s+/g, " ").trim();
    try { if (/%[0-9a-f]{2}/i.test(out)) out = decodeURIComponent(out); } catch {}
    return out.length > CONFIG.LIMBLE_MAX ? out.slice(0, CONFIG.LIMBLE_MAX - 3) + "..." : out;
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // CLIPBOARD & SHARE
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  async function copy(text) {
    try {
      if (navigator.clipboard && window.isSecureContext) {
        await navigator.clipboard.writeText(text);
        return true;
      }
    } catch {}
    try {
      const ta = document.createElement("textarea");
      ta.value = text;
      ta.style.cssText = "position:fixed;top:-9999px";
      document.body.appendChild(ta);
      ta.select();
      ta.setSelectionRange(0, text.length);
      const ok = document.execCommand("copy");
      document.body.removeChild(ta);
      return ok;
    } catch { return false; }
  }

  async function shareVia(p, text) {
    if (navigator.share) {
      try { await navigator.share({ title: `Part ${p.key}`, text }); return; } catch {}
    }
    const ios = /iphone|ipad|ipod/i.test(navigator.userAgent);
    window.location.href = `sms:${ios ? "&" : "?"}body=${encodeURIComponent(text)}`;
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // POPOVER
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  function closePop() {
    if (activePop) { activePop.remove(); activePop = null; }
    if (popTimer) { clearTimeout(popTimer); popTimer = null; }
    document.removeEventListener("click", onDocClick);
    window.removeEventListener("scroll", closePop, true);
  }

  function onDocClick(e) {
    if (activePop && !activePop.contains(e.target)) closePop();
  }

  function openPop(anchor, p, textMsg) {
    closePop();
    const wrap = el("aasPartsFinder");
    if (!wrap) return;

    const pop = document.createElement("div");
    pop.className = "pf-pop";
    pop.innerHTML = `
      <span class="pf-pop__label">Share:</span>
      <button type="button" class="pf-btn pf-btn--mini" data-a="text">Text</button>
      <button type="button" class="pf-btn pf-btn--mini pf-btn--limble" data-a="limble">Limble</button>`;

    pop.querySelector('[data-a="text"]').onclick = async e => { e.stopPropagation(); await shareVia(p, textMsg); closePop(); };
    pop.querySelector('[data-a="limble"]').onclick = async e => {
      e.stopPropagation();
      const w = window.open(CONFIG.LIMBLE_URL, "_blank", "noopener");
      await copy(limbleText(p));
      closePop();
      if (!w) window.location.href = CONFIG.LIMBLE_URL;
    };

    pop.style.cssText = "left:0;top:0;transform:translate(-9999px)";
    wrap.appendChild(pop);

    const ar = anchor.getBoundingClientRect(), pr = pop.getBoundingClientRect();
    let left = ar.left + ar.width / 2;
    left = Math.max(12 + pr.width/2, Math.min(left, innerWidth - 12 - pr.width/2));
    let top = ar.top - 10, tf = "translate(-50%,-100%)";
    if (top - pr.height < 12) { top = ar.bottom + 10; tf = "translate(-50%,0)"; }
    pop.style.cssText = `left:${left}px;top:${top}px;transform:${tf}`;

    activePop = pop;
    setTimeout(() => document.addEventListener("click", onDocClick), 0);
    window.addEventListener("scroll", closePop, true);
    popTimer = setTimeout(closePop, CONFIG.POPOVER_MS);
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // UI RENDERING
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  function skeletons(n = CONFIG.SKELETON_COUNT) {
    const g = el("pfGrid");
    if (!g) return;
    g.innerHTML = Array(n).fill(`
      <div class="pf-skel">
        <div class="pf-skel__top"></div>
        <div class="pf-skel__body">
          <div class="pf-skel__line med"></div>
          <div class="pf-skel__line short"></div>
          <div class="pf-skel__line long"></div>
        </div>
      </div>`).join("");
  }

  function showError(msg, retry) {
    const g = el("pfGrid");
    if (!g) return;
    g.innerHTML = `
      <div class="pf-card pf-card--error">
        <div class="pf-body">
          <div class="pf-state-icon">âš ï¸</div>
          <div class="pf-part">${escapeHtml(msg)}</div>
          <div class="pf-desc">Check your connection and try again.</div>
          <button type="button" class="pf-btn pf-btn--retry" id="pfRetry">â†» Retry</button>
        </div>
      </div>`;
    el("pfRetry")?.addEventListener("click", retry);
    stats("Error");
  }

  function showEmpty() {
    const g = el("pfGrid");
    if (!g) return;
    g.innerHTML = `
      <div class="pf-card pf-card--empty">
        <div class="pf-body">
          <div class="pf-state-icon">ğŸ”</div>
          <div class="pf-part">No parts found</div>
          <div class="pf-desc">Try a different search or manufacturer.</div>
        </div>
      </div>`;
  }

  function buildMfr() {
    const s = el("pfMfr");
    if (!s) return;
    let mfrs = [...new Set(all.map(x => x.manufacturer).filter(Boolean))];
    mfrs.sort((a,b) => a === CONFIG.PINNED_MFR ? -1 : b === CONFIG.PINNED_MFR ? 1 : a.localeCompare(b));
    s.innerHTML = `<option value="">All Manufacturers</option>${mfrs.map(m => `<option value="${escapeHtml(m)}">${escapeHtml(m)}</option>`).join("")}`;
    s.value = mfr;
  }

  function stats(custom) {
    const sEl = el("pfStats"), aEl = el("pfAnnounce");
    const msg = custom || `Showing ${visible.toLocaleString()} of ${filtered.length.toLocaleString()} parts`;
    if (sEl) sEl.textContent = msg;
    if (aEl) aEl.textContent = `${filtered.length} parts found`;
  }

  function setLoading(on) {
    loading = on;
    el("pfGrid")?.classList.toggle("is-loading", on);
  }

  function makeCard(p) {
    const terms = getTerms();
    const card = document.createElement("div");
    card.className = "pf-card";
    card.tabIndex = 0;
    card.setAttribute("role", "article");

    const imgUrl = driveImg(p.image_id);
    card.innerHTML = `
      <div class="pf-imgWrap">
        ${imgUrl ? `<img class="pf-img" loading="lazy" alt="${escapeHtml(p.key)}" src="${imgUrl}">` : `<div class="pf-noimg"><span class="pf-noimg__icon">ğŸ“·</span><span>No image</span></div>`}
      </div>
      <div class="pf-body">
        <div class="pf-part">${highlight(p.key, terms)}</div>
        <div class="pf-mfr">${highlight(p.manufacturer, terms)}</div>
        ${p.mfg_part ? `<div class="pf-mfg">${highlight(p.mfg_part, terms)}</div>` : ""}
        <div class="pf-desc">${highlight(p.description, terms)}</div>
        <div class="pf-row">
          <button type="button" class="pf-btn" data-a="qr">QR</button>
          <button type="button" class="pf-btn pf-btn--share" data-a="copy">Copy</button>
          <a href="${CONFIG.LIMBLE_URL}" target="_blank" rel="noopener" class="pf-btn pf-btn--limble">Limble</a>
        </div>
      </div>`;

    // Image error handler
    const img = card.querySelector("img.pf-img");
    if (img) {
      img.onerror = () => {
        img.replaceWith(Object.assign(document.createElement("div"), {
          className: "pf-noimg",
          innerHTML: '<span class="pf-noimg__icon">ğŸ“·</span><span>No image</span>'
        }));
      };
    }

    card.querySelector('[data-a="qr"]').onclick = () => openModal(p);
    
    const copyBtn = card.querySelector('[data-a="copy"]');
    copyBtn.onclick = async () => {
      const ok = await copy(limbleText(p));
      copyBtn.textContent = ok ? "âœ“ Copied" : "Failed";
      copyBtn.classList.toggle("pf-btn--success", ok);
      setTimeout(() => { copyBtn.textContent = "Copy"; copyBtn.classList.remove("pf-btn--success"); }, CONFIG.FEEDBACK_MS);
      openPop(copyBtn, p, shareText(p));
    };

    return card;
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // FIX #3: RENDER WITHOUT LAYOUT JUMP
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  function render(reset = false) {
    const g = el("pfGrid");
    if (!g) return;
    
    if (reset) {
      // FIXED: Preserve height during clear to prevent collapse
      const currentHeight = g.offsetHeight;
      if (currentHeight > 200) {
        g.style.minHeight = `${currentHeight}px`;
      }
      
      g.innerHTML = "";
      
      // REMOVED: scrollIntoView was causing the jump
      // g.scrollIntoView({ behavior: "smooth", block: "start" });
    }

    const slice = filtered.slice(0, visible);
    
    if (reset && !slice.length) { 
      showEmpty(); 
      // Release min-height after showing empty state
      requestAnimationFrame(() => {
        g.style.minHeight = "";
      });
      return; 
    }

    const frag = document.createDocumentFragment();
    const start = reset ? 0 : g.childElementCount;
    for (let i = start; i < slice.length; i++) frag.appendChild(makeCard(slice[i]));
    g.appendChild(frag);
    
    // FIXED: Release min-height constraint after cards are rendered
    if (reset) {
      requestAnimationFrame(() => {
        g.style.minHeight = "";
      });
    }
  }

  function recompute() {
    setLoading(true);
    filtered = all.filter(matches);
    visible = Math.min(CONFIG.INITIAL_RENDER, filtered.length);
    stats();
    render(true);
    syncURL();
    setLoading(false);
    updateLoadBtn();
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // INFINITE SCROLL
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  function setupScroll() {
    if (observer) observer.disconnect();
    const sentinel = el("pfSentinel");
    if (!sentinel) return;

    observer = new IntersectionObserver(entries => {
      if (entries[0].isIntersecting && visible < filtered.length && !loading) loadMore();
    }, { rootMargin: "300px" });
    observer.observe(sentinel);
  }

  function loadMore() {
    if (visible >= filtered.length) return;
    visible = Math.min(visible + CONFIG.PAGE_SIZE, filtered.length);
    stats();
    render();
    updateLoadBtn();
  }

  function updateLoadBtn() {
    const btn = el("pfLoadMore");
    if (btn) btn.style.display = visible < filtered.length ? "inline-flex" : "none";
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // MODAL
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  function openModal(p) {
    const m = el("pfModal");
    if (!m) return;
    closePop();
    prevFocus = document.activeElement;

    const payload = (p.qr_payload || p.key).trim();
    el("pfModalTitle").textContent = `QR for ${p.key}`;
    el("pfModalSub").textContent = p.manufacturer || "";
    el("pfModalPayload").textContent = payload;
    el("pfModalQR").src = qrImg(payload);

    m.classList.add("is-open");
    m.setAttribute("aria-hidden", "false");
    el("pfModalClose")?.focus();
  }

  function closeModal() {
    const m = el("pfModal");
    if (!m) return;
    m.classList.remove("is-open");
    m.setAttribute("aria-hidden", "true");
    if (prevFocus) { prevFocus.focus(); prevFocus = null; }
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // KEYBOARD NAV
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  function setupKeys() {
    const g = el("pfGrid");
    if (!g) return;

    g.addEventListener("keydown", e => {
      const cards = [...g.querySelectorAll(".pf-card")];
      const cur = document.activeElement?.closest(".pf-card");
      const idx = cards.indexOf(cur);
      if (idx === -1) return;

      let next = -1;
      if (e.key === "ArrowRight") next = Math.min(idx + 1, cards.length - 1);
      else if (e.key === "ArrowLeft") next = Math.max(idx - 1, 0);
      else if (e.key === "ArrowDown") next = Math.min(idx + 3, cards.length - 1);
      else if (e.key === "ArrowUp") next = Math.max(idx - 3, 0);
      else if (e.key === "Enter" || e.key === " ") {
        e.preventDefault();
        cur?.querySelector("button")?.click();
        return;
      }

      if (next !== -1 && next !== idx) { e.preventDefault(); cards[next].focus(); }
    });
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // INIT
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  async function init() {
    skeletons();
    loadURL();
    renderRecent();

    try {
      const { text, cached, stale } = await fetchData();
      
      all = parseCSV(text);
      all.forEach(p => p._blob = buildBlob(p));

      buildMfr();
      recompute();
      setupScroll();
      setupKeys();
      updateLoadBtn();
      
      showStatus(stale);

      // Background refresh if using cache
      if (cached) {
        setTimeout(async () => {
          try {
            const { text: fresh } = await fetchData(false);
            const newAll = parseCSV(fresh);
            if (newAll.length !== all.length) {
              all = newAll;
              all.forEach(p => p._blob = buildBlob(p));
              buildMfr();
              recompute();
              showStatus(false);
            }
          } catch {}
        }, 2000);
      }

    } catch (e) {
      console.error(e);
      showError("Failed to load parts", init);
    }
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // EVENT LISTENERS
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  const debouncedSearch = debounce(v => {
    q = v;
    if (v.length >= 2) saveRecent(v);
    recompute();
  });

  el("pfSearch")?.addEventListener("input", e => debouncedSearch(e.target.value));
  el("pfSearch")?.addEventListener("keydown", e => {
    if (e.key === "Escape" && el("pfSearch").value) {
      el("pfSearch").value = "";
      q = "";
      recompute();
    }
  });

  el("pfMfr")?.addEventListener("change", e => { mfr = e.target.value; recompute(); });
  el("pfLoadMore")?.addEventListener("click", loadMore);
  el("pfModalClose")?.addEventListener("click", closeModal);
  el("pfModal")?.addEventListener("click", e => { if (e.target.classList.contains("pf-modal__backdrop")) closeModal(); });

  document.addEventListener("keydown", e => {
    if (e.key === "Escape") { closeModal(); closePop(); }
    if ((e.ctrlKey || e.metaKey) && e.key === "k") { e.preventDefault(); el("pfSearch")?.focus(); }
    
    // Focus trap in modal
    const m = el("pfModal");
    if (m?.classList.contains("is-open") && e.key === "Tab") {
      const focusable = m.querySelectorAll('button, [href], [tabindex]:not([tabindex="-1"])');
      const first = focusable[0], last = focusable[focusable.length - 1];
      if (e.shiftKey && document.activeElement === first) { e.preventDefault(); last.focus(); }
      else if (!e.shiftKey && document.activeElement === last) { e.preventDefault(); first.focus(); }
    }
  });

  window.addEventListener("popstate", () => { loadURL(); recompute(); });

  init();
})();
</script>